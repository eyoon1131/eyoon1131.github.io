# Project Report

John Li, Dyson Huo, Eliot Yoon, Daniel Kim

Our project is Marble Neon Circuit, a game in which the player races against their opponents to finish the laps around the track the fastest in order to win the race. There are 3 main ways to defeat the opponents. The first is to outmaneuver them through pure driving ability. The second is to utilize the collision physics to impede the other car's movements and knock them off their paths. The third is to pick up the blue speed boost coins and avoid the red slowing coins to improve their speed.

## Algorithms Used

1. Symplectic Euler (for car physics simulation)
2. Hermite Interpolation (for procedural track generation as well as enemy car movement)
3. Collision Detection (for car, items, enemies, and track)
4. Spring-Damper System (for collision response/penalty as well as item movement)
5. Ease-in-out Interpolation (for animations)

### Symplectic Euler

See `./new_scripts/particle.js` for implementation. Our project utilizes the symplectic euler integration algorithm for particle movement. All moving objects (cars and items) in our game are Particle objects, and every time the Simulation's update() function is called, forces are applied to the particles. The User object's ext_force depend on user input, while for the Enemy objects ext_force is calculated such that they follow a randomly generated unique spline path. For the Item objects, they are connected to an anchor particle by a Spring object with 0 damping so that they move in a sinusoidal bobbing motion.

### Hermite Interpolation

Hermite spline interpolation is used not only to generate the track, but also to generate the unique paths for the enemy cars. These paths are generated by adding a randomly generated offset to the track's hermite points and generating a new spline from these offset points. Additionally, the ext_force is calculated by finding the closest point on the path spline to the car's position and calculating that point's tangent and horizontal vectors. The forward acceleration is calculated from the tangent and the sideways acceleration is calculated from the horizontal vector and the distance of the car's position to the closest point on the spline.

### Collision Detection

See `./collision/collision-handling.js` for implementation. Our track is based completely on a curve. So based on the car's location, we search for the closest point on the curve (`getFrame`, `getTimeOnCurve` in `./track/track-generate.js`), then by using the horizontal normal of the curve, we can locate the wall, and we detect collision based on distance to the wall (`detectTrackCollision`). Additionally, collision detection is implemented between Particles. If a collision is detected between two cars, an opposite and equal force is applied to both of them. If a collision is detected between a car and an item, the car receives the effect of the item and the item is removed from the game.

### Spring-Damper System

See `./collision/collision-handling.js` for implementation. When a collision is detected, we apply a penalty force to the car using spring damper system. We use the closest point from a car to the wall to ensure horizontal force application (`handleTrackCollision`). Additionally, the Item objects in `./new_scripts/particle.js` utilize spring-damper systems to generate their movement. The item is attached to a stationary anchor particle by a spring with 0 damping and a rest length of 0, leading to sinusoidal vertical movement.

### Ease-in-out Interpolation

We use ease-in-out when we animate the `3, 2, 1, GO!` as well as `lap completion`. See `./ui/ui.js` for implementation. In `StartAnimation` we use `2^{-5t}` as our easing function to let the numbers go from big to small. Then in `LapAnimation` we also use exponential ease-in and ease-out to slide the upper and lower banners as well as changing the opacity of the banner.

## Track Generation

### Assumptions

- the collider shape for the vehicle is a sphere; the track is C1 continuous.
- the initial position of the collider is always placed in a valid position.
- the width of the track is always wider than the diameter of the sphere, 
  and the closest distance between two points on a track curve is wider than the
  diameter as well.
- the track cannot be vertical at any given time.

### Definitions

Let our sphere collider $S = (\bold{p},r)$ where $\bold{p} \in \mathbb{R}^3$ is
the position, and $r\in\mathbb{R}$ is the radius; the track $T := (f, w)$, where 
curve function $f:\mathbb{R} \cap [0,1] \to \mathbb{R}^3$ and track width 
$w > 2r$.

At a position that meets the above assumptions, we have a function 
$\Phi: \mathbb{R}^3 \to \mathbb{R} \cap [0,1]$. It behaves the same as $f^{-1}$,
when the given point $\bold{x}$ is in the range of $f$; for an $\bold{x}$ not on
the curve, it gives the value $t$ such that $|f(t) - \bold{x}|$ is minimum.

### Track Generation and Collision Detection

Now, consider collider $S := (\bold{p},r)$ and $T := (f, w)$. 

The closest point on $t$ is computed by $t = \Phi(\bold{p})$; hence the point 
$\bold{x}$ on curve $f$ is $\bold{x} = f(t)$. 

Consider the tangent $\vec{f'(t)}$, $\vec{h} := \vec{f'} \times \vec{j}$, 
$\vec{n} := \vec{h} \times \vec{f'}$. Now, $\hat{n}$ is the normal vector when 
calculating the ground in collision, and $\hat{h}$ provides useful information 
when calculating collisions with side walls at this moment. Then, we just need
to decide the distance with the ground and walls and apply the penalty method.

#### Implementation of $\Phi$

Since the track can have multiple bumps, bisection won't work.

A simple implementation can be scanning through $[0,1]$ with $n$ discrete points, and then return the point with smallest distance. The quality entirely depends on how many scan-points we have. However, with too few scan points, the quality can be concerning (a poorly estimated point can give strange forces); with too many scan points, the smoothness of the game can be impacted, since this is computed every physics update frame. Due to this issue, we must find a way to optimize.

To further boost the speed for this process (benchmarking shows that `getFrame` causes a lot of lag), we designed a `pHash` function to cache the results into memory.
This saves a lot of computations and exchanged memory usage for framerate (which is more important in a car racing game). This adds about an additional 150MB usage for a typical 5-lap game.

### Track Models

For rendering out the track, we used a custom model with a custom shader to allow phong lighting with colors. It's completely procedural, meaning that any hermite spline can be used to automatically generate the track.

## UI

### Rendering the basic UI

The idea is that we render the UI based on the camera's position. This is done so through `./ui/ui.js` under `UI` class in `get_transform_custom_cam_projection`. With this function, we can treat the screen as a 2D plane from -1 to 1, allowing us to easily adjust the position of the UI elements.

### Rendering Car avatars for the leaderboard

We do two pass rendering for the car avatars. First we render each of the cars in the scene, then we save them as textures. On the second pass, we draw circles with the generated textures on the leaderboard. This is done in `./ui/ui.js` under `CarAvatar` class as well as `./ui/scene2texture.js`.

### Lap Completion Animation

We use custom parallelogram shape taken from CS 174A to create the banners. We draw three parallelograms for the upper, middle, and lower banners, then we draw the desired text through our `TextLine` class over the banners.
